## 1. 算法
算法的特征： 有穷性，确定性，可行性（算法中描述的操作可以通过已经实现的基本运算执行有限次来实现），输入，输出。
好算法的特征：正确性，可读性，健壮性，高效率，低空间要求。

## 2. 栈
出栈顺序的所有可能值是 $f(n)=\dfrac{1}{n+1}C_{2n}^n$。

## 3. 队列的实现
在这里，`Q.front` 指向队头的元素，而 `Q.rear` 则指向队尾的下一个元素
对于循环队列，`Q.front == Q.rear` 可以表示队满也可以表示队空，此时有三种方法：
1. 留出一个空位置，此时有 `Q.front == (Q.rear + 1) % maxSize` 时表示队满。
2. 加入一个变量表示队列中元素的个数，队满的条件是 `Q.size == maxSize`。
3. 使用一个 `tag`，`tag == 0` 的情况下，由删除导致的 `Q.front == Q.rear` 表示队空，`tag == 1` 的情况下，由插入导致的 `Q.front == Q.rear` 表示队满。
在这里使用空位置的做法。

```c++
#include <cstdio>  
#define MaxSize 50  
  
struct Queue {  
    int data[MaxSize];  
    int front, rear;  
};  
  
void init_queue(Queue& queue) {  
    queue.front = queue.rear = 0;  
}  
  
int empty(Queue& queue) {  
    return queue.rear == queue.front ? 1 : 0;  
}  
  
int enqueue(Queue& queue, int x) {  
    if (queue.rear + 1 % MaxSize == queue.front) {  
        return 0;  
    }  
    queue.data[queue.rear] = x;  
    queue.rear = (queue.rear + 1) % MaxSize;  
  
    return 1;  
}  
  
int dequeue(Queue& queue, int& x) {  
    if (queue.rear == queue.front) {  
        return 0;  
    }  
    x = queue.data[queue.front];  
    queue.front = (queue.front + 1) % MaxSize;  
  
    return 1;  
}  
  
int main() {  
    return 0;  
}
```

## 4. 矩阵的压缩存储
1. 三元组表示法
使用三元组 `(i, j, a)` 来表示在 `(i, j)` 位置的元素 `a`，可以使用线性表来存储其三元组。
2. 伪地址表示法
对二维的地址进行一维的映射后得到伪地址表示法
如果是两维两列，则下面的是第四个元素。
`(1, 1, 1) -> (1, 4)`
3. 十字链表表示法
将矩阵的元素情况构成十字链表，链表有 `down` 指向其下面的元素，还有 `right` 指向其右边的元素。
另外设置数组 `rows` 和 `lines` 来指向对应行或列有的第一个元素。

### 4.1 具体矩阵的压缩存储
1. 对角矩阵
只存放对角线元素。
2. 下三角矩阵
按行存取，只存储下方元素。
3. 上三角矩阵
按行存储，只存储上方元素。
4. 对称矩阵
只存放主对角和下三角元素。

## 5. 树
### 5.1 存储结构
1. 双亲存储结构
具体存放方式是 `(data, parent)`。
2. 孩子存储结构
用类似邻接表的方法来存储所有孩子。
有 `parents[]`, 每个元素都是一个指向最左边孩子的指针，属于同一双亲的孩子通过链表串联起来。
3. 孩子兄弟表示法
每个结点两个指针，分别指向第一个孩子和下一个兄弟。

### 5.2 二叉树
性质：
1. 第 $i$ 层最多 $2^{i-1}$ 个结点。
2. $n_{0}=n_{2}+1$, 度为 $0$ 的结点比度为 $2$ 的结点多一个。
3. $n=n_{0}+n_{1}+n_{2}=2n_{2}+n_{1}+1$。
4. 给定 $n$ 个结点，能构成 $f(n)=\dfrac{1}{n+1}C_{2n}^n$ 种不同的二叉数。

### 5.3 二叉树的顺序存储
使用数组来按层存储二叉树的每个结点。哪怕没有的结点也应留出位置。

### 5.4 线索二叉树
每个结点维护线索指针，可以用于快速遍历二叉树。
每个结点的存储结构 `(val, ltag, rtag, lchild, rchild)`
在 `tag == 1` 时，指向前驱或者后继，在 `tag == 0` 时指向子女。

### 5.5 树和森林
1. 将任意树转换为一颗二叉树
左儿子右兄弟。
对于一个结点转化为二叉树后左儿子是它原本的第一个儿子，而右儿子是它右边第一个兄弟。
2. 森林转换为二叉树
先将所有树转换为二叉树，第一棵二叉树不动，从第二课二叉树开始，依次把后一棵二叉树的根结点作为前一课二叉树的右孩子，用线连接起来。
3. 二叉树转换为森林
分别转换根所在右偏树的每棵子树即可。
4. 树的遍历
先根遍历
先访问根结点再依次遍历子树。
后根遍历
先依次遍历子树再遍历根结点。
5. 森林的遍历
先序
依次使用先序遍历森林。
中序
依次使用中序遍历森林。

### 5.6 哈夫曼树
也叫最优二叉树，其所有结点的带权路径和 $WPL$ 最小。
带权路径：该结点的权值乘上根结点到该结点的路径长度。

哈夫曼树的构造：
每次选择两个权值最小的结点作为左右子树生成新的结点，并将新的结点也加入到结点集合中，直到只有一个结点。

构造完成后，只有叶子结点有数据，此时进行哈夫曼编码，根节点是空，左儿子添上一个 `0`, 右儿子添上一个 `1`。

## 6. 图
无向完全图：任意两个结点之间都有一条直接相连的边，如果是有向则为两条。
强连通: 有向图中任意两个结点之间都有路径可互相到达，则是强连通。
强连通分量：极大强连通子图。

### 6.1 普利姆算法和克鲁斯卡尔算法

### 6.2 dijkstra 算法和 floyd 算法

### 6.3 $AOV$ 网
用顶点表示活动，边表示活动之间的同步关系: $V_{i}$ 必须在 $V_{j}$ 之间进行。
对 $AOV$ 网进行拓补排序可以得到一个可能的活动执行顺序。

### 6.4 $AOE$ 网和关键路径
用顶点表示事件，弧表示活动，边权表示活动的持续事件的有向图是 $AOE$ 图，常用于估算工程的完成事件。
一个 $AOE$ 网只有一个入度为 $0$ 的结点称为源点，也只有一个出度为 $0$ 的点称为汇点，表示结束。
也表示了一种同步关系。

#### 6.4.1 关键路径
关键路径是 $AOE$ 网中从源点到汇点的最长路经，也是整个工程完成的最短时间，其上的活动称为关键活动。
求解步骤是：
找出每个事件的最早发生事件和最迟发生时间，这两者相等的点就是关键活动。
关键路径可能不止一条。

最早发生时间：
从源点到事件 $V_{k}$ 的最长路径是该事件的最早发生时间。

最迟发生时间：
从汇点的最早发生时间减去(汇点到事件 $V_{i}$ 的最长路径)是最迟发生时间，在不推迟整个工期完成的条件下，最迟开始的时间。

## 7. 排序

![[Pasted image 20240628015624.png]]

1. 插入排序
每一步将一个待排序的记录按照其 $Key$ 的大小插到前面已经排序的序列的适当位置。
最坏，最好，平均：$O(n^2),O(n),O(n^2)$。
空间复杂度 $O(1)$。
稳定。

2. 希尔排序
先将整个序列分割成若干子序列分别进行直接插入排序，待整个序列基本有序时，再将全体记录依次进行直接插入排序。

步骤：
1. 选择一个增量值 $gap$, 表示分成的组数。
2. 然后从 $a_{1}$ 开始，每 $gap$ 个元素取一个值，分成 $gap$ 组。
3. 对这些组分别进行直接插入排序。
4. 不断减少组，直到只剩下一组时再进行直接插入排序。
![[Pasted image 20240628012141.png]]

最好时间复杂度 $O(n^{1.3})$, 最坏 $O(n^2)$。
平均 $O(n\log^2n)$
空间复杂度 $O(1)$。
不稳定。

3. 冒泡排序
最坏 $O(n^2)$, 最好 $O(n)$, 平均 $O(n^2)$。
稳定。

4. 快速排序
选择一个中枢，从两边向中枢扫描，不断将右边的元素交换到左边，最后左边都比中枢小右边都比中枢大。此时中枢元素则就位。
最坏 $O(n^2)$ ，平均 $O(n\log n)$，最好 $O(n\log n)$。
不稳定。

```c++
void quick_sort(int a[], int low, int high) {  
    if (low >= high) {  
        return;  
    }  
    int mid = (low + high) / 2;  
    int l = low - 1, r = high + 1;  
  
    while (l < r) {  
        do { l++; } while (a[l] < a[mid]);  
        do { r--; } while (a[r] > a[mid]);  
        if (l < r) {  
            std::swap(a[l], a[r]);  
        }    }  
    quick_sort(a, low, r);  
    quick_sort(a, r + 1, high);  
}
```

5. 选择排序
最坏，最好，平均 $O(n^2)$。
不稳定，空间复杂度 $O(1)$

6. 堆排序
平均，最坏，最好 $O(n\log n)$, 空间复杂度 $O(1)$。
```c++
void sift_down(int arr[], int start, int end) {  
    // 计算父结点和子结点的下标  
    int parent = start;  
    int child = parent * 2 + 1;  
    while (child <= end) {  // 子结点下标在范围内才做比较  
        // 先比较两个子结点大小，选择最大的  
        if (child + 1 <= end && arr[child] < arr[child + 1]) child++;  
        // 如果父结点比子结点大，代表调整完毕，直接跳出函数  
        if (arr[parent] >= arr[child])  
            return;  
        else {  // 否则交换父子内容，子结点再和孙结点比较  
            swap(arr[parent], arr[child]);  
            parent = child;  
            child = parent * 2 + 1;  
        }    }}  
  
void heap_sort(int arr[], int len) {  
    // 从最后一个节点的父节点开始 sift down 以完成堆化 (heapify)    
    for (int i = (len - 1 - 1) / 2; i >= 0; i--) sift_down(arr, i, len - 1);  
    // 先将第一个元素和已经排好的元素前一位做交换，再重新调整（刚调整的元素之前的元素），直到排序完毕  
    for (int i = len - 1; i > 0; i--) {  
        swap(arr[0], arr[i]);  
        sift_down(arr, 0, i - 1);  
    }}
```

7. 归并排序
最快，最好，平均 $O(n\log n)$。
空间复杂度 $O(n)$。
稳定。


8. 基数排序
每次对一位进行排序，对于第 $i$ 位，开 $10$ 个桶，如果这一位是 $k$，就放入对应的桶，添加完毕后从
小的开始收集 ，进行一轮排序。每一位都处理完后得到的序列就有序。

## 8. 查找
1. 顺序查找
$$
ASL=\dfrac{n+1}{2}
$$
2. 二分查找
取中间点作为判定树的根，为 $\dfrac{n}{2}$。同时递归建立左右子树，目标是尽量平衡。
![[Pasted image 20240628021703.png]]
则
$$
ASL_{成功}=\dfrac{\sum 第i层 \times 层的元素个数}{n}
$$
比如这里
$$
ASL_{成功} =\dfrac{1 + 2\times 2 + 3 \times 4 + 4 \times 4 }{11}
$$

对于失败，补充外部节点。
![[Pasted image 20240628021959.png]]

$$
ASL_{失败}= \dfrac{\sum 失败结点个数 \times (层数-1)}{n+1}
$$
比如这里第四层有 $4$ 个失败结点，第五层有 $8$ 个失败结点。
$$
ASL_{失败}=\dfrac{4 \times 3 + 8 \times 4}{12}
$$


### 3. 散列表
1. 线性查探法
第一次计算 $H(key)$ 后冲突，线性向右查找第一个空位置。
2. 二次查探法
第一次计算 $H(key)$ 后冲突，则再计算第二次的 $H(key)=(H(key)+d) \% MOD$, 其中 $d=\pm 1, \pm 2^2, \pm 3^2$ 等。
比如首先计算 $(8+1)\%11$, 再计算 $(8-1)\%11$, 再计算 $(8+4)\%11$，再计算 $(8-4)\%11$ 等。
3. 再散列法
换新的散列函数散列。
4. 装填因子
$$
\alpha = \dfrac{哈希表元素个数}{长度}
$$
其 $ASL$ 跟装填因子有关。
$$
ASL_{成功}= \dfrac{1}{哈希表元素个数}\sum_{i=1}^nC_{i}
$$
其中 $C_{i}$ 表示装入每个元素的比较次数。

查找不成功：
遇到空单元或者是解决冲突的方法完全探测一遍后仍没有。
$$
ASL_{失败}=\dfrac{1}{表长(即MOD)}\sum^{n}_{i=1}C_{i}
$$
