---
title: 操作系统复习
tags:
  - 操作系统
date: 2024.03.15
---
# 1. 计算机系统概述
## 1.1 操作系统的概念
计算机系统自上而下可以划分为 4 部分：硬件，操作系统，应用程序和用户。操作系统管理各种计算机软件，为应用程序提供基础，并且充当计算机硬件与用户之间的中介。
__操作系统是指控制和管理整个计算机系统的硬件与软件资源，合理地组织，调度计算机的工作与资源的分配，进而为用户和其他软件提供方便接口与环境的程序集合，是计算机系统最基本的系统软件__。

### 操作系统的特征
1. 并发
	- 系统具有同时进行运算或操作的特性，在同一时刻可以完成两种或两种以上的工作。在宏观上，有多道程序在执行，而在每个时刻仅有一道程序执行。**CPU 与 I/O 设备 IO 与 IO 设备之间可以实现真正的并行**，如果要实现进程之间的并行需要**多流水线或多处理器**环境的支持。
2. 共享
	- 系统中的资源可供内存中多个并发执行的进程共同使用。资源共享主要方式有**互斥共享和同时访问**两种方式。
	- 互斥共享方式： 打印机，磁带机等在一段时间内只允许一个进程访问资源，这类资源称为临界资源。大多数物理设备以及软件中所用的栈，变量，表格等都属于临界资源。
	- 同时访问方式： 这类资源允许一段时间内由多个进程"同时"访问。这里的同时通常是宏观上的，而在微观上这些进程可能是交替地访问资源，也称为"分时共享"。典型的设备是磁盘设备以及一些用重入代码编写的文件。

**并发和共享是操作系统两个最基本的特征。**
两者互为存在的条件：资源共享是以程序的并发为条件的。如果系统不能对资源进行共享也会影响到并发执行。

3. 虚拟
	- 虚拟是将一个物理上的实体变为若干逻辑上的对应物。用于实现虚拟的技术称为虚拟技术。操作系统的虚拟技术可以归纳为： **时分复用技术**，如虚拟处理器；**空分复用技术**，如虚拟存储器。
4. 异步
	- 进程的执行不是一步到底而是走走停停的，以不可预知的速度推进，这就是进程的异步性。可能导致进程产生与时间有关的错误（如对全局变量的访问顺序不当）。只要运行环境相同，操作系统就需要保证多次运行进程后都能获得相同的结果。

###  操作系统的目标和功能
操作系统应具有以下几方面的功能： 处理机管理，存储器管理，设备管理和文件管理。还必须向用户提供接口。同时可以用于扩充机器以提供更方便的服务和更高的资源利用率。

操作系统也是用户与计算机硬件系统之间的接口，提供的接口主要分为两类：**命令接口和程序接口**
1. 命令接口： 主要分为联机控制方式和脱机控制方式
	1. 联机命令接口，又称为交互式命令接口，适用于分时或实时的操作系统的接口。
	2. 脱机命令接口，又称为批处理命令接口，适用于批处理系统，由一组作业控制命令组成。
2. 程序接口：由一组系统调用（也称为**广义指令**）组成。用户通过在程序中使用这些系统调用来请求操作系统的服务。

没有任何软件支持的计算机称为裸机，覆盖了软件的机器称为扩充机器或者**虚拟机**。
## 操作系统发展历程
分为手工操作阶段，批处理阶段，分时操作系统，实时操作系统，网络操作系统和分布式计算机系统，个人计算机操作系统。

1. 批处理阶段： 为了解决人机矛盾和 CPU 以及 IO 设备之间速度不匹配的矛盾。
	1. 单道批处理系统
		1. 自动性： 磁盘上的作业自动逐个运行，无须人工干预。
		2. 顺序性：作业顺序进入内存，先调入内存的先完成。
		3. 单道性：内存中仅有一道作业驻留，需要等待低速 IO 设备完成。
	2. 多道批处理系统
		1. 多道：计算机内存中同时存在多道相互独立的程序。
		2. 宏观上并行。
		3. 微观上串行。
		4. **优点是资源利用率高，系统吞吐量大。**
		5. **缺点是用户响应的时间长，没有人机交互能力。**
		6. **具有并发和并行的特点**。
2. 分时操作系统： 分时技术是将处理器的运行时间分为很短的时间片，按时间片轮流将处理器分配给各联机作业使用。
	1. 同时性：也叫多路性，允许**多个终端用户同时使用一台计算机**。
	2. 交互性：用户通过终端采用人机对话的方式直接控制程序运行，与同程序进行交互。
	3. 独立性：多个用户可以独立进行操作，互不干扰。
	4. 及时性：可以在很短时间内获得响应。
	5. **解决了人机交互问题，响应时间好**
3. 实时操作系统：
	1. 硬实时系统：某个动作必须绝对在规定时间内完成，比如飞行自动控制系统。
	2. 软实时系统：能够接受偶尔违反时间规定，比如飞机订票，银行管理系统。
	3. **计算机系统接收到外部信号后及时进行处理，并在严格时限内处理完接受事件。及时性和可靠性。交互性不如分时系统**
4. 网络操作系统：提供一种有效使用各台计算机的方法，实现各台计算机之间数据的互相传送。**网络中各种资源的共享和计算机之间的通信**
5. 分布式计算机系统：系统中的计算机都是同等地位，任何工作都可以协作完成，用于管理分布式计算机系统的操作系统称为分布式计算机系统。**分布和并行性**，与网络操作系统不同的是分布式计算机系统的若干计算机相互协同完成统一任务。
6. 个人操作系统： 目前使用最广泛的系统。Windows，linux 和 MacOS 都是个人操作系统。

## 1.3 操作系统的运行环境
### 处理器的运行模式
CPU 将运行模式划分为用户态（目态）和核心态（管态，内核态）。应用程序运行在用户态，内核程序运行在核心态。

内核一般包括四方面的内容：
1. 时钟管理： 时钟的第一功能是计时，另外还可以通过时钟中断的管理实现进程切换。
2. 中断控制
3. 原语： 定义原子操作的直接方法是关中断。
4. 系统控制的数据结构与处理：常见有进程管理，存储器管理和设备管理。

### 中断和异常
中断也叫**外中断**，是 CPU 执行指令外部的事件，通常用于输入输出，如设备发出的 IO 结束中断；**时钟中断**，表示一个时间片已到，让处理机处理计时以及启动定时运行的任务等。
异常也叫**内中断**，是来自 CPU 执行指令内部的事件，比如程序的非法操作码，地址越界，缺页以及 Trap 等的事件，**异常不可被屏蔽**，一旦出现应该立刻处理。

#### 分类
外中断分为**可屏蔽中断和不可屏蔽中断**。
异常分为**故障，中止和陷入（Trap）**。
1. 故障是由指令执行引起的异常，比如非法操作码，取页异常，除 0 以及溢出等，**有可能被处理程序处理**。
2. Trap 是一种事先安排的异常事件，用于在用户态下调用操作系统内核程序，如条件陷阱指令，系统调用等。
3. 终止是出现了使得 CPU 无法继续执行的硬件故障，如控制器出错，存储器校验错等。
4. 故障和 Trap 属于**软件中断**，终止和外部中断属于**硬件中断**。

#### 处理过程
1. 当 CPU 在执行用户程序的第 $i$ 条指令时检测到一个异常事件，或是发现一个中断请求信号，则停止当前的用户程序执行，转到相应的中断或异常处理程序的去执行。
2. 如果中断程序可以解决问题，则回到第 $i$ 或者 $i+1$ 条指令继续执行；如果是不可恢复的致命错误，则中止用户程序。

#### 系统调用
操作系统所提供的一些子功能。每个系统调用都有唯一的系统调用号。拥有设备管理，文件管理，进程控制，进程通信和内存管理等功能。
在处理系统调用时：
1. 先将系统调用号和所需的参数压入堆栈，然后执行一个 Trap 指令进入核心态，再由**硬件和内核共同保护现场，将程序计数器（PC）和程序状态字（PSW）和通用寄存器内容进行保存，其中 PC 和 PSW 由中断隐指令保存，通用寄存器由内核保存**。
2. 第二步是分析系统调用类型，转入相应的系统调用子程序。系统中有系统调用入口表，每个表项都对应一个系统调用，根据调用号可以找到系统调用处理子程序的入口地址。
3. 第三步是系统调用结束后恢复现场。返回被中断进程继续执行。

##### Tips
1. 用户程序在用户态下要使用特权指令引发的中断是陷入中断。
2. 在系统调用时需要保存 PC 和 PSW 的值，而**一般调用只需要保存 PSW 的值**。
3. PC 和 PSW 的值是由中断隐指令保存，不需要由 OS 保存。
## 1.4 操作系统结构
分层法是将操作系统分为若干层，0 层为硬件，顶层为用户接口，**每层只能调用相邻低层的功能和服务**。
优点是便于系统的调试和验证，简化实现。容易维护和扩充。问题是合理定义各层比较困难，依赖关系固定后，**灵活性**较差。**效率**较差。

模块化是将操作系统按功能划分为具有一定独立性的模块，每个模块具有某方面的管理功能，规定好各模块的接口后各模块之间可以使用接口进行通信。也叫模块-接口法。
优点是可以提高操作系统设计的正确性，可理解性和可维护性；增强了可适应性。加速了操作系统的开发过程。
缺点是接口规定很难满足对接口的实际要求；各模块的设计者齐头并进，无法找到一个可靠的决定顺序。

### 宏内核与微内核
宏内核也叫单内核或大内核，系统的主要功能模块都容纳在内核之中，各模块之间共享信息，具有**无可比拟的性能优势**。

微内核是将内核中最基本的功能保留在内核，将不需要在核心态的代码在用户态执行，降低内核的设计复杂性。
微内核的操作系统分为微内核和多个服务器，小型内核通常包含：
1. 与硬件处理紧密相关的部分，如**低级 IO**。
2. 一些较为基本的功能。
3. 客户和服务器之间的通信。
微内核通常使用**机制和策略分离**的原来来组织 OS 结构，微内核通常具有以下功能：
1. 进程管理
2. 低级存储器管理
3. 中断和陷入管理
微内核的特点：
1. 拓展性和灵活性
2. 可靠和安全性
3. 可移植性
4. 分布式计算
其最主要的问题是性能问题，因为需要频繁地在用户态和核心态之间切换。

### 外核
外核用于管理虚拟机，它为虚拟机分配资源，并检测资源的可用性。它只是用于管理硬件资源，不负责完成进程调度等。

### 操作系统引导
引导过程如下：
1. 激活 CPU，激活的 CPU 读取**ROM**中的**boot**程序，将指令寄存器设置为**BIOS**的第一条指令，开始执行**BIOS**的指令。
	- BIOS 是计算机启动时加载的第一个软件，保存着计算机最重要的基本输入输出程序，还包括开机后自检程序和系统自启动程序。
2. 硬件自检，**BIOS**程序在内存最开始的空间构建**中断向量表**，接下来的**POST**过程中会用到中断功能，然后进行**通电自检**，如果无故障屏幕会显示 CPU 内存等信息。
3. 加载带有操作系统的硬盘，通电自检后，**BIOS**开始读取**Boot Sqeuence**（通过**CMos**里保存的启动程序或者是与用户交互的方式），将控制权交给启动顺序排在第一位的存储设备，然后 CPU 将该存储设备**引导扇区**的内容加载内存。
4. 加载主引导记录（**MBR**），硬盘以特定的标识符区分引导硬盘和非引导硬盘。如果发现一个存储设备不是可引导盘，就检查下一个存储设备。无其他启动设备就会死机。**MBR**的作用是告诉 CPU 去硬盘的哪个主分区寻找操作系统。
5. 扫描硬盘分区表，加载硬盘活动分区。**MBR**包括硬盘分区表，硬盘分区表以特定的标识符区分活动分区和非活动分区。MBR 扫描硬盘分区表，进而识别含有 OS 的硬盘分区，找到硬盘活动分区后开始加载硬盘活动分区，将控制权交给活动分区。
6. 加载分区引导记录**PBR**，读取活动分区的第一个扇区，这个扇区称为分区引导记录 PBR，作用是寻找并激活分区根目录下用于引导操作系统的程序（启动管理器）。
7. 加载启动管理器，PBR 搜索活动分区中的启动管理器，加载启动管理器。
简单地说就是
$$
开机 \rightarrow BIOS启动M B R \rightarrow MBR启动激活分区PBR \rightarrow 启动 PBR \rightarrow 启动系统
$$
### 虚拟机
第一类虚拟机是直接在硬件上取代了操作系统的位置，运行在最高特权级，裸机上。
第二类虚拟机是运行在内核上的一个用户软件。

# 2. 进程和线程
## 2.1 进程
进程是程序执行的一次执行过程，是**动态**的。

## 2.2 进程的组成
进程是独立的运行单位，也是 OS 进行资源分配和调度的基本单位。
它由： **进程控制快，程序段，数据段**组成。
最核心的是进程控制块 (PCB)。

### 2.2.1 PCB
PCB 通常包含以下内容：
1. 进程描述信息: 进程标识符 (PID)，用户标识符（UID）
2. 进程控制和管理信息：进程当前状态，优先级，代码运行入口地址，程序外存地址，进入内存时间，CPU 占用时间，信号量使用。
3. 资源分配清单：代码段指针，数据段指针，堆栈段指针，文件描述符，鼠标，键盘
4. 处理机相关信息：通用寄存器值，地址寄存器值，控制寄存器值，标志寄存器值，状态字。

### 2.2.2 程序段
程序段是能被进程调度执行到的 CPU 代码片段，程序段是只读的，可被多个进程共享。

### 2.2.3 数据段
存放运行过程中产生的各种数据。

上述三个统称为进程实体，**进程实体是静态的**。
所以说**进程是进程实体的运行过程，是资源分配和调度的基本单位**。
PCB 是进程存在的唯一标志。

## 2.3 进程的特征
进程的特征有：动态性，并发性，独立性，异步性，结构性。
另外，并发的进程会失去**封闭性**，封闭性是指进程的程序运行结果只取决于自身，而不受外界的影响。失去封闭性后，共享变量会导致其执行结果和速度有关。


## 2.4 进程的状态与转换，进程的组织
进程的五态:
1. 运行态：进程正在 CPU 上运行。
2. 就绪态：进程已经获得除 CPU 外的一切资源，系统中处于就绪态的进程被组成为就绪队列
3. 阻塞态：进程正在等待某一事件而暂停，是进程主动选择的，阻塞态的进程一般也被排成一个或多个阻塞队列。
4. 创建态：进程正被创建，尚未转到就绪态。
5. 终止态：进程正在从系统上消失。进程首先转换到终止态，然后进一步完成资源释放和回收等工作。
进程的状态由 PCB 进行记录。

### 2.4.1 状态转换
![[Pasted image 20240503141541.png]]


### 2.4.2 进程的组织
各个进程的 PCB 以某种方式组织起来，常用的有**索引方式和链接方式**，对应起来也就是数组和链表。
连接方式：不同状态维护一个头指针结合为链表。
索引方式：不同状态维护一个索引表。

## 2.5 进程控制
进程控制就是管理进程的状态转换。
实现进程控制需要**原语**。
进程转换的操作是先设置 state，然后将其转移到其他的状态队列。由于这两个操作的不可分割性，可以使用原子操作。
原子操作原子性是由**开中断和关中断**这两个特权指令实现的。
**将进程唤醒**指的是**阻塞态到就绪态**。
### 2.5.1 进程有关的原语
1. 创建原语：申请空白 PCB，为新进程分配资源，初始化 PCB，插入 PCB 到就绪队列。
2. 撤销原语：找到对应 PCB，若进程正在运行则剥夺使用权，重新分配 CPU，终止所有子进程，释放资源归还给父进程或 OS，释放 PCB。
3. 阻塞原语：找到对应 PCB，保护进程运行现场，设置状态为阻塞态，暂停进程运行，将 PCB 插入相应事件的等待队列。
4. 唤醒原语：找到 PCB，将 PCB 从等待队列移除，设置为就绪态，将 PCB 插入就绪队列，等待调度。
5. 切换原语：将环境信息存入 PCB，PCB 移入相应队列，选择另一个进程运行，更新 PCB，根据 PCB 恢复新进程所需环境。
总体来说都是三件事：更新 PCB 信息，将 PCB 插入合适队列，分配或回收资源。

## 2.6 进程通信（IPC）
进程通信是指两个进程之间的数据交互。
需要进程通信的原因是，各进程拥有的内存地址空间是相互独立的。

### 2.6.1 共享存储
1. 基于存储区的共享： 操作系统在内存中划分出一块共享存储区，数据的形式，存放位置都由通信进程控制，是一种高级通信方式。
2. 基于数据结构的共享：规定只能用固定大小的数组等进行共享，低级共享方式。

### 2.6.2 消息传递
使用格式化的消息来共享信息。使用发送和接收原语，分为直接通信和间接通信。
间接通信是以信箱作为中间实体进行消息传递。

### 2.6.3 管道通信
管道是一种特殊的共享文件，实质就是开辟在内存中的一个大小固定的内存缓冲区。
单向管道拥有一个发送方和一个接收方。
管道和共享内存的区别是，管道类似于队列，而共享内存支持**随机存取**。
可以用两个单向管道实现双工通信。
各进程需要互斥地使用管道。

## 2.7 线程
线程是基本的 CPU 执行单元，是程序执行流的最小单位。
线程的存在可以提高系统的并发性，相同进程的线程切换几乎不耗费系统资源。

### 2.7.1 线程的实现方式
用户级线程和内核级线程。
用户线程是由应用程序通过线程库实现：
1. 所有的线程管理工作都是由应用程序负责。
2. 用户级线程中，线程切换可以在用户态下完成，无须操作系统干预。
3. 用户级线程对操作系统透明。
4. 优点是切换可以在用户空间完成，不需要切换到核心态，系统效率高开销小。
5. 缺点是一个用户级线程被阻塞后，整个进程都会被阻塞，降低了并发度，另外多个线程不可在多核处理机上并发执行。
相当于说，用户线程只是线程库模拟出来的线程。
内核级线程是操作系统实现的线程，由操作系统负责管理：
1. 操作系统管理
2. 切换在核心态下
3. 对操作系统不透明
4. 当一个线程被阻塞后依然可以继续执行，提高了并发能力。多线程可在多核上并行。

### 2.7.2 多线程模型
分为一对一模型，多对一模型， $n$ 对 $m$ 模型。
一对一：一个用户级线程映射到一个内核级线程，相当于上述的内核级线程。
多对一：多个用户级线程映射到一个内核级线程，相当于上述的用户级线程。
$n$ 对 $m$ 模型：$n$ 个用户级线程映射到 $m$ 个内核级线程 $n\geq m$，克服了多对一并发度不高的问题，又克服了一对一模型中一个用户进程占用太多内核级线程，开销太大的缺点。

## 2.8 线程的组织与控制
线程使用线程控制块 TCB，保存了 TID，程序计数器 PC，其他寄存器，堆栈指针，线程运行状态（用于保存和恢复），优先级等信息。


## 2.9 进程的调度
分为高级调度，中级调度，和低级调度
1. 高级调度：也叫作业调度，是将外存的作业中选择一个调入内存，并创建 PCB，**只会被调入一次调出一次**。
2. 低级调度：也叫处理机调度，是将就绪队列中选择一个分配处理机。
3. 中级调度：也叫内存调度，将挂起状态的进程调入内存。发生的频率比高级调度高。

### 2.9.1 七状态模型
加入了挂起状态。
![[images/Pasted image 20240503191015.png]]


### 2.9.2 进程调度的时机
进程无法在**操作系统内核程序临界区**中进行调度和切换。但是**不**代表**进程处于临界区时不能进行处理机调度**。内核资源临界区一般是用于访问某种内核数据结构，比如进程的就绪队列等。访问普通临界区可进行内核调度和切换。

### 2.9.3 进程调度的方式
分为抢占式和非抢占式。


### 2.9.4 进程的切换和过程
**狭义的进程调度**指的是从就绪队列中选择一个要运行的进程。而进程切换是指一个进程让出处理机，另一个进程占用处理机的过程。
**广义的进程调度包含了选择进程和进程切换两个步骤**。
在支持内核级线程的多线程系统里，调度器调度的对象就变成了线程。

### 2.9.5 闲逛进程
在没有其他就绪进程时运行闲逛进程。一般是零地址指令，能耗低。

### 2.9.6 调度算法的评价指标
1. CPU 利用率： CPU 忙碌的时间占总时间的比例。
2. 系统吞吐量： 单位时间内完成作业的数量。
3. 周转时间：作业被提交给系统开始，到作业完成为止的时间间隔。也就是作业完成时间 - 作业提交时间。
4. 平均周转时间： 各作业周转时间之和 / 作业数量。
5. 带权周转时间： 作业周转时间 / 作业实际运行时间。
6. 平均带权周准时间： 带权周转时间之和 / 作业数。
7. 等待时间： 进程处于等待处理机状态时间之和。
8. 响应时间： 用户从提交请求到首次产生响应的时间。

### 2.9.7 调度算法
1. 先来先服务算法（FCFS），该算法没有抢占式。
2. 短作业优先（SJF），最短的作业或进程优先得到服务，抢占版本为最短剩余时间算法（SRTN），追求最短的平均等待，平均周转，平均带权周转。拥有最短的这三个的是 SRTN，如果所有进程几乎是同时到达，同时可运行时 SJF 也拥有最短的这三者。
3. 高响应比优先（HRRN）
响应比：
$$
\frac{等待时间+要求服务时间}{要求服务时间}=1+\frac{等待时间}{要求服务时间}
$$
4. 时间片轮转调度算法（RR）
5. 优先级调度算法
6. 多级反馈队列调度算法
设置多级反馈队列，各队列优先级从高到低，时间片从小到大，新进程进入第一级队列，按照 FCFS 分配，若用完时间片还未结束，则进入下一级队列尾，如果已经是最后一级队列，则重新回到一级队列。
7. 多级队列调度算法
系统按进程类型设置多个队列，进程创建成功后插入某个队列，各个队列优先级和时间片可能不同，也可以使用不同的调度算法。

其中**先来先服务**对长作业有利；也对 CPU 繁忙型作业有利，CPU 繁忙型作业可以看作是长作业，IO 密集型作业会频繁阻塞，不会长时间占用 CPU。

### 2.9.8 计算方法
调度算法计算周转时间等可以使用数轴：
![[Pasted image 20240505190737.png]]
在数轴上标出分界点，完成的进程画圈，用结束时间减去任务提交时间即可得周转时间。

有 IO 设备等可以并行的设备可以使用表格法：
$P_{1},P_{2},P_{3}$ 的分别的输入，运行，输出时间是 $2,3,4$:
![[Pasted image 20240505191023.png]]
从上到下和从左到右都具有先后顺序。 ***个人***感觉比甘特图更简单。

## 2.10 同步与互斥
临界资源： 需要互斥访问的资源。
访问临界资源的四个过程：
```cpp
do {
	entry section; // 进入区
	critical section; // 临界区
	exit section; // 退出区
	remainder section; // 剩余区
} while (true)
```
进入区： 检查是否可进入临界区，若能进入还应该阻止其他进程进入临街区。
临界区：访问临界资源的代码。
退出区：清除访问临界区的标志。
剩余区：其他部分。

### 2.10.1 四个原则
1. 空闲让进：临界区空闲时，可以允许进程进入临界区。
2. 忙则等待： 当有进程在临界区时，其他进程必须等待。
3. 有限等待： 请求进入的进程必须在有限时间内进入临界区，防止无限等待。
4. 让权等待（非必须）：当进程不能进入临界区时应该立刻释放处理器，防止进程忙等待。

### 2.10.2 软件实现方法
1. 单标志法
```cpp
int turn = process_id; // 当前允许进入临界区的进程号

while (turn != process_id):
critical section;
turn = other_process_id;
remainder section;
```
基本的思想就是**检查是否轮到自己使用临界资源，使用完成后，设置进程号为其他的，让对方使用临界区**。但是如果设置的进程一直没有进入临界区，就会违背**空闲让进**的原则。

2. 双标志法
```cpp
while (flag[other_prcess_id]);
flag[process_id] = true;
critical section;
flag[process_id] = false;
remainder section;
```
基本的思想就是**检测对方是否在使用临界区，如果对方没使用，就设置自己的 flag 值为 true，相当于上锁的过程；退出时解锁。**
但是如果两个进程是并发运行，当一个进程在检查完 `while` 后还没有设置标记，另外一个进程就开始运行，会导致两个进程同时进入临界区，违背了**忙则等待**的原则。
问题就是检查和上锁的动作不能一次完成。

3. 双标志后检查法
```cpp
flag[process_id] = true;
while (flag[other_prcess_id]);
critical section;
flag[process_id] = false;
remainder section;
```
先检查后上锁。**并发时可能会导致两个进程同时上锁**，就会死锁。违反了**有限等待**的原则。

4. $\mathrm{Peterson}$ 算法
```cpp
flag[process_id] = true;
turn = other_process;
while (flag[other_process] && turn == other_process);
critical section;
flag[process_id] = false;
remainder section;
```
结合了双标志和单标志，`flag` 表示进程是否想进入临界区，`turn` 表示让其他进程先使用临界区。`turn` 的值最终表示了哪个进程可以进入临界区。也就说最后给 `turn` 的值可以使用。违反了**让权 等待**的原则。

### 2.10.3 硬件实现方法
1. 中断屏蔽方法
在访问临界区时关开中断，缺点是不适用于多处理机（关中断只对执行指令的处理机有用，另外不受影响）；只适用于操作系统内核进程，不能让用户进程控制中断。
2. $\mathrm{TestAndSet}$ 指令 ($TS$ 或 $TSL$)
原子操作。功能是读出指定的标志后设置标志为真。
```cpp
while (TestAndSet(&lock));
critical section;
lock = false;
//...
```
进入上锁，完成解锁。违反了**让权等待**。
3. $\mathrm{Swap}$ 指令（$\mathrm{Exchange}$ 或 $\mathrm{XCHG}$）
原子操作。交换两个变量的值。
```cpp
bool old = true;
while (old) {
	Swap(&lock, &old);
}
// ...
lock = false;
// ...
```
跟 $TS$ 指令相同。

### 2.10.4 互斥锁 ($\mathrm{Mutex}$)
使用 `acquire()` 获得锁，`release()` 释放锁。自旋锁会导致忙等待。用于多处理机系统中，其他核不会忙等待。

### 2.10.5!!! 信号量
1. 整型信号量
表示一个资源的数目的整型变量 $S$，三种操作初始化，$\mathrm{wait(P),signal(V)}$。
$\mathrm{P}表示申请资源，\mathrm{V}表示释放资源$。
在整型信号量中资源不足也会导致忙等待。
$\mathrm{P,V}$ 操作是一种**低级进程通信原语**。

2. 记录型信号量
在整型信号量的基础上，如果资源不足会导致进程自阻塞从而让出处理机。资源足够时又会唤醒进程。不会导致忙等待。
```cpp
typedef struct {
	int value;
	struct process* L;
} semaphore;
```
#### 2.10.5.1 信号量实现互斥
```cpp
semaphore S = 1;

process() {
	P(S);
	// ...;
	V(S);
}
```

#### 2.10.5.2 信号量实现同步
```cpp
semaphore S = 0;

process1() {
	// ...
	V(S); // 表明已完成
}

process2() {
	P(S); // 检查已完成
}
```

#### 2.10.5.3 信号量实现前驱
对前驱图的每条有向边定义一个信号量。每条有向边其实就代表了一个同步关系。
![[Pasted image 20240505201144.png]]

### 2.10.6 生产者-消费者问题
```cpp
semophore mutex = 1;
semophore empty = n;
semophore full = 0;

producer() {
	while(true) {
		produce;
		P(empty); // 消耗空闲
		P(mutex);
		add;
		V(mutex);
		V(full); // 增加产品
	}
}

consumer() {
	while (true) {
		P(full); // 消耗产品
		P(mutex);
		get;
		V(mutex);
		V(empty); // 增加空闲
		consume; 
	}
}
```
**实现互斥的操作一定要在实现同步的 $\mathrm{P}操作之后$（对后面的几种模型都一样）**。互斥锁只需要包住临界区即可。

### 2.10.7 多（类）生产者-多（类）消费者
```cpp
semaphore apple = 0;
semaphore orange = 0;
semaphore plate = 1;

dad() {
	while (true) {
		//..;
		P(plate);
		//..;
		V(apple);
	}
}

mom() {
	while (true) {
		//..;
		P(plate);
		//..;
		V(orange);
	}
}

son() {
	while (true) {
		P(orange);
		//..;
		V(plate);
	}
}

daughter() {
	while (true) {
		P(apple);
		// ..;
		V(plate);
	}
}
```
因为缓冲区大小最多为 $1$, 拥有 $\mathrm{Mutex}$ 效果，所以可以不用互斥。如果缓冲区大于一就需要设置互斥。

### 2.10.8 吸烟者问题
一个供应者进程和三个抽烟者进程，一根烟需要三种材料，三个抽烟者中每个只有其中一种材料，而供应者会提供两种材料。让三个抽烟者轮流吸烟。
```cpp
semaphore offer1 = 0, offer2 = 0, offer3 = 0, finish = 0;
int num = 0;

P1() {
	while (true) {
		num++;
		num %= 3;

		if (num == 0) V(offer1);
		else if (num == 1) V(offer2);
		else V(offer3);

		P(finish);
	}
}

P2() {
	while (true) {
		P(offer3);
	// ..;
		V(finish);
	}
}

P3() {
	while (true) {
		P(offer2);
	// ..;
		V(finish);
	}
}

P4() {
	while (true) {
		P(offer1);
	// ..;
		V(finish);
	}
}
```

### 2.10.9 读写者问题
不能同时写但是可以同时读。
```cpp
semaphore rw = 1, mutex = 1;
int cnt = 0;

writer() {
	while (true) {
		P(rw);
		writing;
		V(rw);
	}
}

reader() {
	while (true) {
		P(mutex);
		if (cnt == 0) P(rw);
		cnt++;
		V(mutex);
		reading;
		P(mutex);
		cnt--;
		if (cnt == 0) V(rw);
		V(mutex);
	} 
}
```
由第一个读者负责加锁，最后一个负责解锁。刚来的开灯，最后走的关灯。
会导致写者饿死的问题。

相同优先级的写法：
```cpp
semaphore rw = 1, mutex = 1, w = 1; // w 保证写者优先
int cnt = 0;

writer() {
	while (true) {
		P(w);
		P(rw);
		writing;
		V(rw);
		V(w);
	}
}

reader() {
	while (true) {
		P(w);
		P(mutex);
		if (cnt == 0) P(rw);
		cnt++;
		V(mutex);
		V(w);
		reading;
		P(mutex);
		cnt--;
		if (cnt == 0) V(rw);
		V(mutex);
	} 
}
```

### 2.10.10 哲学家问题
五位哲学家环坐，一共只有五只筷子，每位哲学家只能拿左手和右手边的筷子。
```cpp
semaphore cs[] = {1, 1, 1, 1, 1};
semaphore mutex = 1;

Pi() {
	do {
		P(mutex);
		P(cs[i]);
		P(cs[(i+1)%5]);
		V(mutex);
		// ..;
		V(cs[i]);
		V(cs[(i+1)%5]);
		// ..;
	} while (1);
}
```
$\mathrm{V}$ 操作可以不用互斥，因为不会导致阻塞。

### 2.10.11 信号量问题的基本步骤
1. 分析各进程间的制约关系，从而得出同步与互斥关系  
2. 根据 1中的分析，设置信号量  
3. 编写伪代码，实施 P,V 操作
同步：多个进程在执行次序上的协调，相互等待消息  
互斥：对临界资源的使用
要注意的是，**虽然 P,V 操作在每一个进程中都是成对出现的，但不一定是针对一个信号量。互斥信号量的 P,V 操作总是出现在一个进程中的临界区的前后，而同步信号量的 P,V 操作总是出现在具有同步关系的两个进程中，需要等待消息的一方执行 P 操作，发出消息的一方执行 V 操作。**

### 2.10.12 管程
管程是自带互斥功能的类。每次仅允许一个进程进入管程，从而实现进程**互斥和同步**。
基本的操作是 `take_away()` 申请资源，`give_back()` 归还资源。
特点：
1. 需要在管程中定义共享数据，例如缓冲区。
2. 需要在管程中定义访问共享数据的函数。
3. 只有需要的入口才可以访问共享数据。
4. 管程中每次只能开放一个入口，让一个**进程或线程**进入，互斥特性是***编译器***实现的，而同步特性是**编程语言**支持的。
5. 可在管程中定义条件变量以及等待唤醒以解决同步问题，可以让一个线程或进程在条件变量上等待。此时进程应该先释放管程使用权，让出入口；可以通过唤醒操作将等待在管程上的进程或者线程唤醒。
管程的条件变量是引发进程阻塞的原因，与信号量不同的是，信号量有值，而条件变量仅仅维护阻塞队列。
### 2.11 死锁
死锁发生的必要条件：
1. 互斥条件： 只有对互斥资源的争抢才会导致死锁。
2. 不可剥夺条件： 进程获得的资源在未使用完前，不能由其他进程夺走。
3. 请求和保持条件： 进程已经保持了至少一个资源，提出新的资源请求请求其他进程所持有的资源，此时请求进程被阻塞，但是又不放弃自己的资源。
4. 循环等待条件： 存在进程资源的循环等待链。
对不可剥夺的资源的不合理分配就可能会导致死锁。

### 2.11.1 死锁的预防
破坏互斥条件：
将互斥资源改造程允许共享使用，比如 $\mathrm{SPOOLing}$ 技术。

破坏不可剥夺条件：
1. 当进程申请的资源无法满足，立刻释放自己的所有资源。
2. 当进程申请的资源无法满足时，由操作系统协助，将想要的资源强行剥夺。

破坏请求和保持等待：
采用静态分配办法，在一次申请全部资源。

破坏循环等待条件：
采用顺序资源分配法，给进程编号，规定按编号递增的顺序请求资源。

### 2.11.2 死锁的避免
以一个序列分配资源如果能让进程资源全部满足，则是安全序列。
银行家算法： $\mathrm{DFS}$ 寻找安全序列。
当系统处于安全状态时，系统中一定无死锁进程，也一定不会死锁。
当系统处于不安全状态时，系统不一定会死锁。
### 2.11.3 死锁的检测和解除
死锁检测：用数据结构保存资源分配和请求信息，再用算法检测是否已进入死锁状态。
![[Pasted image 20240506132545.png]]
如果可以消去图中所有的边，说明不会发生死锁。
在资源分配图中，找出不阻塞又不是孤立点的进程，消除它所有的请求边和分配点，让它成为孤立点。如果找到一种方法可以消除所有边，则图**可完全简化**，不会死锁。

**死锁定理**：如果资源分配图中没有环路则系统中没有死锁，如果图中有环路可能会死锁，如果每个资源类只包含一个资源实例，则环路是存在死锁的充要条件。

死锁解除: 资源剥夺法，终止进程法，进程回退。

# 3. 内存管理
基本的要求是**内存空间的分配和回收，地址转换，内存空间的扩充，内存共享，内存保护**。

三种装入方式：
1. 绝对装入： 编译时产生绝对地址。
2. 可重定位装入： 装入时将逻辑地址转换为物理地址。
3. 动态运行时装入： 运行时将逻辑地址转换为物理地址，需要设置重定位寄存器。

操作系统通过内存管理部件（$\mathrm{MMU}$）来实现逻辑地址转换为物理地址。

内存保护的方法：
1. 设置上下限寄存器。
2. 设置重定位寄存器（基地址寄存器）和界地址寄存器（限长寄存器）来进行检查。

## 3.1 覆盖和交换
覆盖技术： 按照逻辑让不可能被同时访问的程序段共享覆盖区，覆盖区是程序员自己声明的。
交换技术： 内存空间紧张时，将内存中某些进程暂时换出外存，将外存中已具备运行条件的进程换入内存。暂时换出外存的进程是挂起态，分为就绪挂起和阻塞挂起态。

## 3.2 连续分配的管理方式
系统为用户进程分配一个连续的内存空间。

单一连续分配： 将系统分为系统区和用户区，系统区位于低地址部分，**内存中只能有一道用户程序**。无外部碎片。
固定分区分配： 将用户空间划分为若干个固定大小的分区，在每个分区中只装入一道作业。操作系统需要建立一个分区说明表，来说明分区是否被分配。无外部碎片。
动态分区分配： 不预先划分内存分区，而是根据装入内存时进程大小动态建立分区。可以使用**空闲分区表和空闲分区链**来维护。有外部碎片。

## 3.3 分配算法
1. 首次适应算法： 空闲分区按地址递增的次序排列，每次分配按顺序查找空闲分区表，找到第一个满足大小的分区。
2. 最佳适应算法： 空闲分区按容量递增的次数排列。
3. 最坏适应算法：空闲分区按容量递减次数排列。
4. 邻近适应算法： 按地址递增排列，每次分配时从上次查找结束的位置开始查找空闲分区表。
5. 伙伴系统： 规定分区大小是 $2^k$, 当需要为进程分配大小为 $n$ 的分区时 $(2^{i-1}\leq n\leq 2^i)$ ，在大小为 $2^i$ 的空闲分区链查找，找到则分配，否则表示分区已经耗尽，需要在大小为 $2^{i+1}$ 的空闲分区链继续查找，若存在则将其分为两个分区，这两个就称为**一对伙伴**，其中一个用于分配，另外一个就加入大小为 $2^i$ 的空闲分区链，回收时也可能需要对伙伴分区进行合并。
## 3.4 基本分页存储
将内存空间分为一个个大小相等的分区 ,称为页框。
将地址的逻辑地址分为和页框大小的页或页面。
操作系统以页框为基本单位分配空间。
各个页面不必连续存放。

### 3.4.1 页表
页表由页表项组成，页表项由页号和块号组成。
![[Pasted image 20240506172107.png]]
也就是页号-页框号，表示进程的每一页在哪个页框里面。
页号可以是隐含的，不占用存储空间。所以可以不必存储页号的信息。
$$
页号 = \frac{逻辑地址}{页面大小}
$$
$$
偏移量 = 逻辑地址\mod{页面大小}
$$

### 3.4.2 基本地址变换机构
在系统中设置页表寄存器 ($\mathrm{PTR}$), 存放**页表在内存中的起始地址**和**页表长度**。
如果页表的逻辑地址是 $2^k$, 那么可以把逻辑地址看作是二进制的页号和页内偏移量的拼接，后面 $k$ 位代表偏移量，前面单独取出来是页号。
1. 根据逻辑地址计算出页号和偏移量。
2. 检查页号是否越界。
3. 查询页表找到页表对应的页表项，确定页框号。
4. 用页框号和偏移量算出物理地址。

### 3.4.3 具有快表的地址变换机构
快表又叫联想寄存器 $\mathrm{TLB}$, 它不是内存，不是寄存器，而是一种高速缓存，用来存放最近访问的页表项的副本，可以加入地址变换的速度。快表中存储的是**页表项**。
加入快表后会先查询快表。
有的系统支持快慢同时查询，差距就是快表不命中的时候不包含访问快表的时间。但是命中的话还是需要查询快表的时间。

### 3.4.4 两级页表
多级页表是为了解决页表项（在内存中）占用空间过大的问题。可以允许页表项离散存储。
![[Pasted image 20240506183402.png]]
把页表也认为是页装进页框里面。再用顶级页表寻找二级页表，进而找到内存。
多级页表省内存的原因是，二级页表可以按需创建。页表是数组的索引，假如只用到了 $[2]$ 和 $[98]$, 剩下的位置也需要全部留出来，哪怕没有使用它，而有了二级页表之后二级页表只需要按需创建即可。二级页表甚至可以换到外存去存储。

## 3.5 基本分段存储
地址空间按照程序自身逻辑关系划分为若干段，每个段有一个段名，每段从 $0$ 开始编址。
分段系统的逻辑地址结构由段号和段内地址组成，段号位数决定了每个进程最多分为几个段，而段内地址位数决定了每个段的最大长度是多少。
段表记录了逻辑段和物理段的关系。

![[Pasted image 20240509194631.png]]

**段表寄存器**存放了**段表始地址**和**段表长度**两个信息。
所以地址转换的流程就是：
1. 根据逻辑地址得到段号，段内地址
2. 判断段号是否越界，如果则产生越界中断。
3. 查询段表找到对应的段表项。
4. 检查段内地址是否超过短长，如果则产生越界中断，否则继续执行。
5. 物理地址，段基地址+段内地址。

不能被修改的代码称为纯代码或者是**可重入代码**，可以共享访问。
分页管理不会产生外部碎片，只有少量内部碎片，而分段管理会有外部碎片，且更容易实现信息共享与保护。

## 3.6 段页管理
逻辑地址由段号，页号，页内偏移量组成。
段页式管理中，段表项又**段号，页表长度，页表的页框号（页表起始地址）组成**，每个段表项长度相等，段号隐含。
![[Pasted image 20240509200439.png]]
一个进程只会一个段表，一个段表会对应多个页表。

地址转换过程：
1. 根据逻辑地址得到段号，页号，偏移量。
2. 检查段号是否越界。
3. 查询段表找到页表项。
4. 检查页号是否越界。
5. 根据页表存放块号，页号查询页表，找到页表项。
6. 根据内存块号，业内偏移量得到最终物理地址。

## 3.7 虚拟内存
将会用到的部分才调用内存，不用的换出外存。
拥有三个特征：
1. 多次性： 无需一次全部调入内存，可以允许多次调入。
2. 对换性： 在作业运行时无需一直常驻内存。
3. 虚拟性： 逻辑上扩充内存容量。
最主要的区别就是： 需要访问的信息不在内存时，将信息调入内存，内存不足时再换出外存。
实现虚拟内存基于离散分配的内存管理方式。

### 3.7.1 请求分页管理方式
页表新增**状态位（是否在内存中），访问字段（可记录最近被访问几次，或着记录上次访问的时间），修改位（页面调入内存后是否被修改果），外存地址**。

为了实现请求分页需要实现缺页中断机构：
在请求分页系统中，当要访问的页面不在内存中时，便产生一个缺页中断，然后由操作系统的**缺页中断处理程序**处理中断。
此时缺页的进程被**阻塞**，放入阻塞队列，掉页完成后再将其唤醒，放回就绪队列。

如果内存中有空闲块，则分配一个，装入页面到该块，修改页表项，如果没有则由页面置换算法选择一个页面淘汰，如果被修改过还需要写回外存。

地址变换机构：
当访问信息不在内存时，需要由操作系统将所需信息调入内存，若内存空间不够还需要将用不到的信息换出外存。


### 3.7.2 置换算法
目的是追求最低缺页率。
1. 最佳置换算法
选择淘汰永不使用或者最长时间内不被使用访问的页面。
2. 先进先出置换算法
每次淘汰最早进入内存的页面。
只有它有 $\mathrm{Belady}$ 异常。
3. 最近最久未使用算法 ($\mathrm{LRU}$)
淘汰最近最久未使用的页面，用访问字段记录该页面被上次访问以来所经理的时间，选择最大的页面。
4. 时钟置换算法 ($\mathrm{CLOCK}$)
也叫最近未使用算法 $\mathrm{NRU}$, 为每个页面设置一个访问位，再将页面都链接成循环队列。当某页面被访问时设置访问位置为 $\mathrm{1}$, 当需要淘汰时，检查访问位，如果是 $0$ 就换出，如果是 $1$, 就设置为 $0$。
若第一次扫描中所有页面都是 $1$, 那么将这些页面的访问位依次设置为 $0$ 后进行第二轮扫描，因此一次 $\mathrm{C\mathcal{L}OCK}$ 算法最多会经过两轮扫描。
5. 改进型的 $\mathrm{CLOCK}$ 算法
再添加一个修改位，优先淘汰没有被修改过的页面，因为没有修改过的页面不用写回外存。用 $(访问，修改)$。
1. 扫描 $(0,0)$ 用于替换，不修改任何标志位。
2. 扫描 $(0,1)$ 用于替换，将访问位设置为 $0$。
3. 扫描 $(0,0)$ 用于替换，不修改任何标志位。
4. 扫描 $(0,1)$ 用于替换。
最多进行四轮扫描。

### 3.7.3 页面分配策略
驻留集： 请求分页存储管理中给进程分配的物理块的集合。驻留集大小一般大于进程的总大小。
固定分配: 驻留集大小不变。
随机分配：大小可变。
局部置换：发生缺页时只能选自己的物理块进行置换。
全局置换：可以将操作系统保留的和其他进程持有的物理块置换到外存。
可以组合： 固定分配局部置换，可变分配全局置换（只要缺页就分配新的物理块），可变分配局部置换（根据缺页率动态增加和减少物理块数量）。

如果系统有足够的对换区空间，页面调入调出都是在内存和对换区进行，如果不足，则不会被修改的从文件区调入，会被修改的和对换区调入。

抖动现象： 进程频繁访问的页面数目高于可用的物理快数（分配给进程的物理块数目不足）。
工作集 ： 某段时间间隔里，进程实际访问页面的集合。

### 3.7.4 内存映射文件
便于访问文件，使用 `mmap` 系统调用映射文件到内存，就可以按内存的方式来访问文件（支持随机存取）。多个进程也可以映射同一个文件以实现**共享**。

# 4. 文件管理
文件分为有结构文件和无结构文件，无结构文件又叫流式文件，有结构文件有一组相似的记录组成，又叫记录式文件，每条记录由若干数据项组成，一般来说每条记录有一个数据项作为关键字。
根据各条记录的长度是否相等，又可以分为**定长记录**和**可变长记录**。
优结构文件分为三类： 顺序文件，索引文件，索引顺序文件。
顺序文件：文件中的记录逻辑上连续存储，物理上可顺序可链式。顺序文件又可以分为串结构和顺序结构，串结构记录之间的顺序和关键字无关，顺序结构记录之间的顺序按关键字顺序排列。
索引文件：建立一张索引表以加快文件的检索速度，每条记录对应一个索引项 $(索引号,长度,指针)$。
索引顺序文件：一组记录对应一个索引表项，对关键字进行分组，再根据每组的第一个关键字再建立索引表。

## 4.1 文件目录
使用 $\mathrm{FCB}$ 文件控制块来管理文件，一个就是一个文件目录项，里面包含了文件的基本信息，文件名，物理地址，逻辑结构物理结构等，存取控制信息，使用信息等。最重要最基本的还是文件名和文件存放的物理地址。
单级目录结构：只有一个主目录结构。
两极目录结构：分为主文件目录和用户文件目录。
多级目录结构：又叫树形目录结构，文件路径名是字符串，从根目录出发的路径是绝对路径。