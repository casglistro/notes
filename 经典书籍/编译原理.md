# 1. 词法分析
将程序源代码切分为一个一个 `token`, 从字符流到 `token` 流。
`token` 的类型定义
```C++
enum kind { IF, LPAREN, ID, INTLIT, ... }

struct token {
	enum kind k; // 类型
	char* value; // 值
}
```

## 1.1 手工构造法
通俗来说就是自己写词法分析器。
其核心是**转移图**。
![[Pasted image 20240515171201.png]]
简单的说就是根据转移图来编写 `if-else`，其中的 `*` 表示回滚，因为 `other` 读取到的字符不能与前面的连接，应该重新计算。
许多语言里标识符和关键字有交集，因此有以下办法可以处理：
1. 
![[Pasted image 20240515171805.png]]
将标识符独立出来判断。
2. 关键字表算法
构造包含了所有关键字的哈希表 $H$, 对所有的标识符和关键字，先统一按照标识符的转移图进行识别，在识别完成后再根据 $H$ 查看是关键字还是标识符。

## 1.2 词法生成器的生成器
完全自动化的方法，只需要写词法规则的声明就可以自动生成词法生成器。

## 1.3 正则表达式
对给定的字符集 $\sum={c_{1},c_{2},..,c_{n}}$, 归纳定义
- 空串 $\epsilon$ 是正则表达式。
- 对于任意 $c \in \sum$, $c$ 是正则表达式。
- 如果 $M,N$ 是正则表达式，那么以下也是正则表达式
	- 选择 $\mathrm{M|N=\{M,N\}}$
	- 连接 $\mathrm{MN=\{mn|m \in M, n \in N\}}$
	- 闭包 $\mathrm{M* = \{\epsilon, M, MM,MMM\dots\}}$
也就是
$$
\begin{align}
e \rightarrow&\  \epsilon \\
 \rightarrow& \ | \ c \\
\rightarrow& \ | \ e \ | \ e \\
\rightarrow& \ | \ e \ e \\
\rightarrow& \ | \ e*
\end{align}
$$

其他的诸如 $[c_{1}-c_{n}],e+,e?,e\{i,j\}$ 等都是语法糖，其实都可以翻译成上面几个最基本的运算。

## 1.4 有限状态自动机
$\mathrm{FA}$ 接收一个字符串，返回是否能否识别这个字符串 $\mathrm{Yes} \ or \ \mathrm{No}$。
$$
M=( \sum,S,q_{0},F, \delta)
$$
分别代表字母表，状态集，初始状态，终结状态集，转移函数。
![[Pasted image 20240515173320.png]]
约定只有一个单向箭头的状态是起始状态，双圈状态是终结状态。
如果状态机的状态转移不确定，则称为非确定性自动机 $\mathrm{NFA}$, 如果确定叫 $\mathrm{DFA}$。
![[Pasted image 20240515173553.png]]
它们的区别就是在回答上述的“接收或者拒绝”的难度不一样，在这里的状态机中，如果输入是 $\mathrm{a}$，起始在 $0$ 号状态，可以回到 $0$ 号（非终结状态），理应拒绝，也可以到 $1$（终结状态），理应接受。如果可以走到接收状态，那么串就可以被接收，所以在 $\mathrm{NFA}$ 上可能会需要使用遍历等操作。

## 1.5 正则表达式转换 $\mathrm{DFA}$
对于自动生成的词法器，流程如下
$$
\mathrm{RE \xrightarrow{Thompson算法} NFA \xrightarrow{子集构造算法} DFA \xrightarrow{Hopcroft 最小化算法} 词法分析器代码}
$$

### 1.5.1 $\mathrm{Thompson}$ 算法
基于对 $\mathrm{RE}$ 结构做归纳，对于基本的 $\mathrm{RE}$ 直接构造，对复合的 $\mathrm{RE}$ 递归构造。
基本 $\mathrm{RE}$:
![[Pasted image 20240515190827.png]]
中间加一个空串递归起来更加工整直接。

选择：
![[Pasted image 20240515190938.png]]

闭包：
![[Pasted image 20240515191224.png]]

### 1.5.2 子集构造算法
- $\epsilon-closure(n)$ 代表从状态 $n$ 开始经过任意条空串边可以到达的状态的集合。
- $move(q,c)$ 代表从集合开始经过一个 `c` 字符可以到达的状态的集合(`c` 可以是数字，英文，和任意其他可见和不可见字符)。
首先对起始状态求其 $\epsilon$ 闭包 `q0`，加入 `q0` 到集合表，不断取出集合表中的集合 `qi`,  然后遍历字符集，对于从这个闭包中经过某个字符一步可以得到的状态 ` move(qi, c) `, 再对 ` move(qi, c) ` 求对应的 $\epsilon$ 闭包，新的集合为 ` qk `, 如果 ` qk ` 不在集合表中，则加入，并且根据 ` qk ` 等再求对应 ` move(qk, c) ` 的 $\epsilon$ 闭包。在集合表中的集合就是 $\mathrm{DFA}$ 中的集合。而从 ` e-closure(move(qi, c)) ` 生成的 ` qk ` 就代表一条从 $q_{i} \xrightarrow{c} q_{k}$ 的转换边。

子集构造算法(工作表算法)：
```c++
auto q0 = eps_closure(n0) // 从起始开始
auto Q = {q0} // 标记q0为已知
workList.push(q0) // 加入工作表， 栈或者队列均可

while (workList != []) // 不为空
	auto q = workList.pop() // 取出一个集合
	for (auto c : [(字符集)]) // 遍历出字符集的所有字符
 		auto t = eps_closure(move(q, c)) // 求move(q,c)的eps_closure
 		D[q, c].push(t) // 构造转换边
 		if (t not in Q)
	 		Q.push(t)
	 		workList.push(t)
```

手算可以使用表格法：
![[Pasted image 20240515200850.png]]
其中的 $A$ 就是由起始状态得出来的 $q_{0}(e-closure(n_{0}))$, 也是新的起始状态。$a,b$ 分别表示经过 $move(q,c)$ 后得到的 $e-closure(move(q,c))$, 不同的结果对应的是不同的状态。填完表后如果 $A$ 可以得到 $B$ 则有 $A \rightarrow B$ 的转换边。

### 1.5.3 $\mathrm{Hopcroft}$ 最小化算法
基于等价类的思想。
```c++
split(S) // 将 S 通过 c 切换为很多子集
	foreach (char c)
		if (c can split S)
			split S into T1, ..., Tk;

hopcroft()
	split all nodes into N, A // 先切分为两个子集 N 拒绝状态， A 接收状态
	while (set is still changes)
		split(S) // 
```
$N$ 就是非终结状态之外的状态，$A$ 是所有终结状态之间的集合。